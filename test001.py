import re


# Тестовое задание: Калькулятор
# Задача: https://docs.google.com/document/d/1ZrjiCh9sGp7xlxwduzViRuOForfOngK2m3nv2uqYrvM/edit?tab=t.0#heading=h.73h8uq8af6hz

def main(inputstr: str):
    
    # Валидация введенной строки согласно ТЗ
    # Собственно, ТЗ настолько зажатое в рамки, что достаточно взять regex,
    # проверяющий наличие числа 1...10, одного из арифметических знаков,
    # еще одного числа 1...10 и сколько угодно пробелов между ними и по бокам
    # (чтобы не чистить строку от пробелов через strip и т.п.)
    pattern = re.compile(r'[ ]*([1-9]|10)[ ]*(\+|-|\*|/)[ ]*([1-9]|10)[ ]*')

    # матчим ввод через fullmatch
    pmatch = pattern.fullmatch(inputstr)
    
    if pmatch:
        
        # чтобы деление в eval() было целочисленным, надо заменить / на //
        inputstr = inputstr.replace('/', '//')
        
        # может выглядеть как дебилизм, но eval() работает точно по ТЗ, игнорируя пробелы
        result = eval(inputstr)
        return result
        
    else:
        # Этого достаточно, потому что ТЗ не предусматривает раздельных исключений
        # для разных типов ошибок (например, не нужно уточнять, что не то число ввели)
        raise ValueError("Данное выражение, согласно ТЗ, не обрабатывается")
   



if __name__ == "__main__":
    # Приветствие
    print("Это простой калькулятор. Принимает на вход арифметические выражения.")
    print("Формат выражений: 7 + 3, числа только от 1 до 10,")
    print("операции только + - * /")
    print("Введите exit или CTRL+C чтобы выйти.")
    inputstr = input("Введите выражение: ")
    if inputstr == "exit" or inputstr == "EXIT":
        print("Пока-пока!")
        quit()
    # ловить исключение в ТЗ не прописано, так что просто вызываем main "как повезет"
    result = main(inputstr)
    print(f'Результат: {result}')
    
